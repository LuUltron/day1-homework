/* Security configuration of the "traffic light" example. */
/* nk.basic._ is required for comparison operations support in policies, like != below */
use nk.basic._

/* Definition of the execute interface. */
execute: kl.core.Execute

/* Import the file with the declaration of basic security policy aliases. */
use nk.base._

/* Declaration of entities. */
use EDL Einit
use EDL kl.core.Core

use EDL traffic_light.ControlSystem
use EDL traffic_light.LightsGPIO
use EDL traffic_light.DiagnosticSystem
use EDL traffic_light.CommunicationSystem

use EDL Einit
use EDL kl.core.Core
use EDL kl.VfsRamFs
use EDL kl.VfsSdCardFs
use EDL kl.VfsNet
use EDL kl.rump.Dhcpcd
use EDL kl.drivers.SDCard
use EDL kl.drivers.RAMDisk
use EDL kl.drivers.BSP
use EDL kl.drivers.GPIO

/* Execution of entities allowed. */
execute {
    grant ()
}

request
{
    /* Allows the tasks to send requests to the KasperskyOS kernel. */
    match dst = kl.core.Core
    {
        match src = Einit                                 { grant () }
        match src = traffic_light.ControlSystem           { grant () }
        match src = traffic_light.LightsGPIO              { grant () }
        match src = traffic_light.DiagnosticSystem        { grant () }
        match src = traffic_light.CommunicationSystem     { grant () }
        match src = kl.drivers.BSP                        { grant () }
        match src = kl.drivers.GPIO                       { grant () }
        match src = kl.rump.Dhcpcd                        { grant () }
        match src = kl.drivers.RAMDisk                    { grant () }
        match src = kl.VfsNet                             { grant () }
        match src = kl.VfsRamFs                           { grant () }
        match src = kl.VfsSdCardFs                        { grant () }
        match src = kl.drivers.SDCard                     { grant () }
        match src = kl.VfsRamFs                           { grant () }
        match src = kl.VfsRamFs                           { grant () }
    }
    
    /* Allows for initialization calls */
    match dst = Einit
    {
        match src = traffic_light.ControlSystem                    { grant () }
        match src = traffic_light.LightsGPIO                       { grant () }
        match src = traffic_light.DiagnosticSystem                 { grant () }
        match src = traffic_light.CommunicationSystem              { grant () }
    }

    /* Allows all requests from the core */
    match src = kl.core.Core                              { grant () }

    /* Allows all requests from initialization */
    match src = Einit                                     { grant () }

    /* Strict access configuration for the communication with the server:
       we additionally check source, endpoint and used for the request method
     */
    match dst = traffic_light.Server endpoint = Server.ping method = Ping
    {
        match src = traffic_light.Client2                          { grant () }
        match src = traffic_light.Client                           { grant () }
        match src = traffic_light.Connector                        { grant () }
    }

    match dst = traffic_light.ControlSystem endpoint = controls.mode method = FMode
    {
        match src = traffic_light.Client2                          { grant () }
        match src = traffic_light.Client                           { grant () }
        match src = traffic_light.CommunicationSystem                        { grant () }
    }



    match src = traffic_light.CommunicationSystem 
    {
        match dst = kl.VfsSdCardFs                        { grant () }
        match dst = kl.VfsRamFs                           { grant () }
        match dst = kl.VfsNet                             { grant () }
    }
    match src = kl.rump.Dhcpcd, dst = kl.VfsRamFs         { grant () }
    match src = kl.rump.Dhcpcd, dst = kl.VfsNet           { grant () }
    match src = kl.VfsSdCardFs, dst = kl.drivers.SDCard   { grant () }
    match src = kl.VfsRamFs, dst = kl.drivers.RAMDisk     { grant () }
}



/*
request src=traffic_light.CommunicationSystem 
    dst=traffic_light.ControlSystem 
    endpoint=controls.mode
    method=FMode {
        grant ()
}

request src=traffic_light.ControlSystem 
    dst=traffic_light.CommunicationSystem 
    endpoint=communications.mode 
    method=FMode {
        grant ()
}

request src=traffic_light.DiagnosticSystem 
    dst=traffic_light.ControlSystem
    endpoint=controls.mode 
    method=FMode {
        grant ()
}

request src=traffic_light.ControlSystem 
    dst=traffic_light.DiagnosticSystem
    endpoint=diagnostics.ping
    method=FPing {
        grant ()
}
*/
request src=traffic_light.LightsGPIO 
    dst=traffic_light.DiagnosticSystem 
    endpoint=diagnostics.ping 
    method=FPing {
        grant ()
}

/* Разрешены все комбинации кроме зеленый-зеленый и зеленый-зеленый в комбинации с другими цветами*/
/* Запрещены комбинации зеленый-только желтый и зеленый с красным на любом направлении*/
request src=traffic_light.ControlSystem 
    dst=traffic_light.LightsGPIO 
    endpoint=lightsGpio.mode 
    method=FMode {
        assert ((message.value < 0x404 && message.value != 0x206 && message.value != 0x20e)
        || (message.value >= 0x900 && message.value < 0xc04 && message.value != 0xa06 && message.value != 0xa0e)
        || message.value == 0x601 || message.value == 0x603 || message.value == 0x609 || message.value == 0x60a || message.value == 0x60b
        || message.value == 0xe01 || message.value == 0xe03 || message.value == 0xe09 || message.value == 0xe0a || message.value == 0xe0b)
}




/* Response messages allowed. */

response {
    grant ()
}

/*
response src=traffic_light.LightsGPIO 
    dst=traffic_light.ControlSystem 
    endpoint=lightsGpio.mode 
    method=FMode {
        assert (message.result < 0x1000404)
}
*/

error {
    grant ()
}

/* Calls to the security interface are ignored. */
security {
    grant ()
}
